#' Configure movement random effects
#'
#' The `generate_move()` function is used to configure movement random effects.
#'
#' @param basic_info Information generated by \code{\link{generate_basic_info}}.
#' Note: NAA_where has to be specified in basic_info using \code{\link{generate_NAA_where}}.
#' @param move.type Movement type
#'   \itemize{
#'     \item \code{1} unidirectional movement (i.e. only 1 stock can move), region-specific movement rate
#'     \item \code{2} bidirectional movement (i.e. all stocks can move), region-specific movement rate (default)
#'     \item \code{3} no movement
#'   }
#' @param move.rate Movement rate (default = c(0.3, 0.1))
#' @param move.re Movement random effects
#'   \itemize{
#'     \item \code{"constant"} constant movement rate across years and ages (default).
#'     \item \code{"iid_y"} movement rate deviations vary by year, but uncorrelated.
#'     \item \code{"iid_a"} movement rate deviations vary by age, but uncorrelated.
#'     \item \code{"ar1_y"} movement rate deviations correlated by year (AR1).
#'     \item \code{"ar1_a"} movement rate deviations correlated by age (AR1).
#'   }
#' @param move.sigma Sigma for movement random effects (default = 0.2)
#' @param prior.sigma Standard deviation for normal priors on mean movement (default = 0.2) 
#' @param move.rho_a Correlation for movement random effects by ages, only used if move.re = "ar1_a" (default = 0.5)
#' @param move.rho_y Correlation for movement random effects by years, only used if move.re = "ar1_y" (default = 0.5)
#' @param use.prior Logical, whether to use priors (default = TRUE)
#'
#' @return A named list with the following components:
#'   \describe{
#'     \item{$stock_move}{Length = n_stocks, TRUE/FALSE whether each stock can move. If not provided, movement will be defined below for all stocks.}
#'     \item{$separable}{Length = n_stocks, TRUE/FALSE whether movement should be modeled separably from mortality or both occurring simultaneously.}
#'     \item{$must_move}{Array (n_stocks x n_seasons x n_regions) 0/1 indicator whether movement from a region must occur.}
#'     \item{$can_move}{Array (n_stocks x n_seasons x n_regions x n_regions) 0/1 indicator whether movement can occur from one region to another.}
#'     \item{$mean_vals}{Array (n_stocks x n_seasons x n_regions x n_regions - 1) of initial movement rate parameters from each region.}
#'     \item{$sigma_vals}{Array (n_stocks x n_seasons x n_regions x n_regions - 1) of initial standard deviations for random effects.}
#'     \item{$cor_vals}{Array (n_stocks x n_seasons x n_regions x n_regions - 1 x 2) of initial correlation values for random effects.}
#'     \item{$use_prior}{Array (n_stocks x n_seasons x n_regions x n_regions - 1) 0/1 indicator whether to include prior for mean movement parameters in joint log-likelihood.}
#'     \item{$prior_sigma}{Array (n_stocks x n_seasons x n_regions x n_regions - 1) of standard deviation parameters for normal priors on mean movement parameters on transformed scale (-Inf,Inf).}
#'   }
#'
#' @export
#'
#' @seealso \code{\link{set_move}} and \code{\link{generate_NAA_where}}
#'
#' @examples
#' \dontrun{
#' data <- generate_basic_info()
#' data <- generate_move(data, move.type = 2, move.rate = c(0.3,0.2), move.re = "constant")
#' }
generate_move <- function(basic_info, 
                          move.type = 2,
                          move.rate = c(0.3, 0.1), 
                          move.re = "constant",
                          move.sigma = 0.2,
                          prior.sigma = 0.2,
                          move.rho_a = 0.5,
                          move.rho_y = 0.5,
                          use.prior = TRUE) {
  
  if (is.null(basic_info)) stop("basic_info must be provided.")
  
  sep_move <- if(any(names(basic_info) %in% "mig_type")) !as.logical(basic_info$mig_type) else FALSE
  
  n_stocks <- basic_info$n_stocks
  n_regions <- basic_info$n_regions
  n_seasons <- basic_info$n_seasons
  fracyr_spawn <- basic_info$fracyr_spawn
  
  if (n_stocks != n_regions) stop("The current version only allows n_stocks = n_regions") 
  if (length(move.rate) != n_regions) stop("length of movement rates must be equal to n_regions") 
  if (!move.re %in% c("constant","iid_a","iid_y","ar1_a","ar1_y")) stop("move.re can only be constant, iid_a, iid_y, ar1_a, ar1_y")
  
  spawntime <- assign_season(fracyr_spawn, n_seasons)
  movetime <- setdiff(1:n_seasons, spawntime)
  
  if (move.type != 3 && is.null(move.re)) stop("move.re must be specified unless move.type = 3")
  if (move.type != 3 && is.null(move.rate)) stop("move.rate must be specified unless move.type = 3")
  
  move <- list(stock_move = NULL, separable = sep_move, must_move = NULL, can_move = NULL, mean_vals = NULL)
  
  if (move.type == 1) { # Unidirectional movement
    if(sum(move.rate[2:n_stocks]) != 0) {
      move.rate[2:n_stocks] = 0
      cat("Only stock 1 'can' move so movement rate for other stocks is set to be 0!\n")
    }
    move_mu <- move.rate[1]
    move$stock_move <- c(TRUE, rep(FALSE, n_stocks - 1))
    move$must_move <- array(0, dim = c(n_stocks, n_seasons, n_regions))
    move$can_move <- array(0, dim = c(n_stocks, n_seasons, n_regions, n_regions))
    
    move$must_move[1, spawntime - 1, setdiff(1:n_regions, 1)] <- 1
    move$can_move[1, movetime, , ] <- 1
    move$can_move[1, spawntime, setdiff(1:n_regions, 1), ] <- 1
    move$can_move[, spawntime, , ] <- 0
    move$can_move[1, spawntime - 1, 1, ] <- 0
    move$can_move[1, spawntime - 1, setdiff(1:n_regions, 1), ] <- 1
    
    move$mean_vals <- array(move_mu, dim = c(n_stocks, n_seasons, n_regions, n_regions - 1))
    cat(paste0("Only stock 1 'can' move (default)\nMovement rate is ", move.rate[1], "\n"))
    
    move <- configure_move.re(move, move.type, move.re, move.sigma, prior.sigma, move.rho_a, move.rho_y, n_stocks, n_seasons, n_regions, use.prior)
    
  } else if (move.type == 2) { # Bidirectional movement
    move_mu <- move.rate
    move$stock_move <- rep(TRUE, n_stocks)
    move$must_move <- array(0, dim = c(n_stocks, n_seasons, n_regions))
    move$can_move <- array(0, dim = c(n_stocks, n_seasons, n_regions, n_regions))
    
    for (s in 1:n_stocks) {
      move$must_move[s, spawntime - 1, setdiff(1:n_regions, s)] <- 1
      move$can_move[s, movetime, , ] <- 1
      move$can_move[s, spawntime - 1, s, ] <- 0
    }
    
    move$mean_vals <- array(0, dim = c(n_stocks, n_seasons, n_regions, n_regions - 1))
    
    for (r in 1:n_regions) {
      move$mean_vals[, , r, ] <- move_mu[r]
    }
    
    cat(paste0("All stocks 'can' move (default)\nMovement rate for stocks in region 1 is ", move.rate[1], 
               "\nMovement rate for stocks in other regions is ",move.rate[-1],"\n"))
    
    move <- configure_move.re(move, move.type, move.re, move.sigma, prior.sigma, move.rho_a, move.rho_y, n_stocks, n_seasons, n_regions, use.prior)
    
  } else if (move.type == 3) { # No movement
    move <- NULL
  }
  
  return(move)
}

# Helper function to configure movement random effects
configure_move.re <- function(move, move.type, move.re, move.sigma, prior.sigma, move.rho_a, move.rho_y, n_stocks, n_seasons, n_regions, use.prior) {
  
  if (move.re == "constant") {
    
    cat("\nMovement is assumed at a constant rate without random effects\n")
    move$mean_model <- matrix("constant", n_regions, n_regions - 1)
    
    if (use.prior) {
      move$use_prior <- array(0, dim = c(n_stocks, n_seasons, n_regions, n_regions - 1))
      move$use_prior[1, 1, , ] <- 1
      move$prior_sigma <- array(prior.sigma, dim = c(n_stocks, n_seasons, n_regions, n_regions - 1))
    } else {
      move$use_prior <- array(0, dim = c(n_stocks, n_seasons, n_regions, n_regions - 1))
      move$prior_sigma <- NULL
    }
    
  } else {
    
    cat("\nMovement is treated as random effects\n")
    move$mean_model <- matrix("constant", n_regions, n_regions - 1)
    
    if (use.prior) {
      move$use_prior <- array(0, dim = c(n_stocks, n_seasons, n_regions, n_regions - 1))
      move$use_prior[1, 1, , ] <- 1
      move$prior_sigma <- array(prior.sigma, dim = c(n_stocks, n_seasons, n_regions, n_regions - 1))
    } else {
      move$use_prior <- array(0, dim = c(n_stocks, n_seasons, n_regions, n_regions - 1))
      move$prior_sigma <- NULL
    }
    
    if (move.re %in% c("ar1_y", "iid_y")) {
      cat("\nMovement is treated as varying by years\n")
      if (move.re == "ar1_y") {
        move$year_re <- matrix("ar1", n_regions, n_regions - 1)
        move$cor_vals <- array(0, dim = c(n_stocks, n_seasons, n_regions, n_regions - 1, 2))
        move$cor_vals[, , , , 2] <- move.rho_y
        cat(paste0("\nar1_y rho for movement is set to ", move.rho_y, "\n"))
      } else if (move.re == "iid_y") {
        move$year_re <- matrix("iid", n_regions, n_regions - 1)
      }
      if(move.type == 1) {
        move$year_re[2:n_regions] = "none"
      }
    }
    
    if (move.re %in% c("ar1_a", "iid_a")) {
      cat("\nMovement is treated as varying by ages\n")
      if (move.re == "ar1_a") {
        move$age_re <- matrix("ar1", n_regions, n_regions - 1)
        move$cor_vals <- array(0, dim = c(n_stocks, n_seasons, n_regions, n_regions - 1, 2))
        move$cor_vals[, , , , 1] <- move.rho_a
        cat(paste0("\nar1_a rho for movement is set to ", move.rho_a, "\n"))
      } else if (move.re == "iid_a") {
        move$age_re <- matrix("iid", n_regions, n_regions - 1)
      }
      if(move.type == 1) {
        move$age_re[2:n_regions] = "none"
      }
    }
    
    move$sigma_vals = move.sigma
    cat(paste0("\nsigma for movement is set to ", move.sigma, "\n"))
  }
  return(move)
}

# Helper function to assign seasons
assign_season <- function(fraction, n_seasons) {
  season_fraction <- 1 / n_seasons
  season <- ceiling(fraction / season_fraction)
  return(season)
}
